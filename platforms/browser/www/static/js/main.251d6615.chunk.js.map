{"version":3,"sources":["components/layout/Header.js","components/TodoItem.js","components/Todos.js","components/pages/About.js","components/Addtodo.js","App.js","serviceWorker.js","index.js"],"names":["headerStyle","background","color","textAlign","padding","linkStyle","textDecoration","Header","style","to","TodoItem","getStyle","borderBottom","props","todo","completed","this","id","title","type","onChange","markComplete","bind","onClick","delTodo","btnStyle","Component","border","borderRadius","cursor","float","class","Todos","todos","map","key","About","Fragment","Addtodo","state","onSubmit","e","preventDefault","addtodo","setState","target","name","value","display","flex","placeholder","className","App","axios","delete","then","res","filter","post","data","get","exact","path","render","component","Boolean","window","location","hostname","match","renderReactDom","ReactDOM","document","getElementById","cordova","addEventListener","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.251d6615.chunk.js","sourcesContent":["// header is just a functional component because there's not going to be any state or anything, it's basically just markup and is the first time we're looking at a function based component (which is pretty easy)\n\n// functional component is one return, which works like render does\n\n\nimport React from 'react';\nimport { Link } from 'react-router-dom';\n\nfunction Header() {\n  return (\n    <header style={headerStyle}>\n      <h1>TodoList</h1>\n      <Link style={linkStyle} to=\"/\">Home</Link> | <Link style={linkStyle} to=\"/about\">About</Link>\n    </header>\n  )\n}\n//exporting function\n\nconst headerStyle = {\n  background: '#333',\n  color: '#fff',\n  textAlign: 'center',\n  padding: '10px'\n}\n\nconst linkStyle = {\n  color: '#fff',\n  textDecoration: 'none'\n}\n\nexport default Header;","import React, { Component } from 'react';\n//TodoItem also has a prop of todo, so we import PropTypes\nimport PropTypes from 'prop-types';\n\n\nexport class TodoItem extends Component {\n    //getStyle with any parameters it takes and arrow function, we want to strike through completed items props contains current Todo. This is called dynamic styling\n  \n  \n    getStyle = () => {\n        return {\n          background: \"#f4f4f4\",\n          padding: \"10px\",\n          borderBottom: \"1px #ccc dotted\",\n          textDecoration: this.props.todo.completed ? \"line-through\" : \"none\",\n        };\n      };\n      //Adding method. Want to use arrow functions. When u have an event and calling a method it takes an event parameter. However below code produces error saying can't read props of undefined, so there are 2 options (1) bind (reason we can use that in render or other life cycle methods is because it's part of component class), however this is a custom method rather than component class, so doesn't have access, so we do following. \n\n      // since we're not using a state manager like Redux and we're not using the context API we have to basically climb the tree or what is it called component drilling. Basically we have our state inside of our app.js file so we can't  where basically we can't simply say this.set state you and then change the completed value to true or false. We have to climb the ladder climb the and we have to go from to-do item to todos and then into App.js' and the way we do that is through props and we recreate methods inside of our props and we call those. So instead of having the method below, we do as follows (see under render - added prop and by doing so, I go to todos (next level up) and to where TodoItem is and add )\n      //markComplete= (e) => {\n          //console.log(this.props)\n      //}\n    //this is called restructing, where we're pulling out values and is easier way\n    render() {\n        const {id,title, completed} = this.props.todo;\n\n        return (\n            //in JSX we can actually use inline style which allows us to have our markup our, our functionality and our styling all within our component, so lets add styling in <div> and we use double {} for inline styling. There is no hyphenatio in inline styling and camelCase is used. Also double curley braces {{ backgroundColor: '#9999ff' }} can be used instead of variable\n            //we can use const variable as set out below\n            //<div style={itemStyle}> \n            \n            //can also add style as function, so use a method in a class\n            <div style={this.getStyle()}>\n            {/* {''} is an expression with a space} and we add an event onChange, same as vanilla javascript only camelCase using method. Binding method below shows props but better way to do this is to add an arrow function (put = and then arrow) in method (above render)*/}\n                {/*binding, as we have access todo*/}\n                {/*<input type=\"checkbox\" onChange={this.props.markComplete.bind(this, this.props.todo.id)} />{''}*/}\n                {/*destructuring - pulling out values of id and title, passing id up through todos and app.js (now we can grab id in app.js)*/}\n                <p>\n                <input type=\"checkbox\" onChange={this.props.markComplete.bind(this, id)} />{''}\n                {/*<input type=\"checkbox\" onChange={this.markComplete.bind(this)}/>{''}*/}                   \n                { title }\n                {/*adding an event so something happens when x button is clicked} - doing same thing with props, sending onClick style up to were our state is (App.js). We use destructuring for id variable*/}\n                <button onClick={this.props.delTodo.bind(this, id)} style={btnStyle}>x</button>\n\n                </p>\n                {/*<p>{ this.props.todo.title }</p>*/}\n            </div>\n        )\n    }\n}\n//PropTypes\n//we want to define any prop-types for this class\n\n//so name of class (Todos) and then a single object of Prop, and is required. This is good practice to do\nTodoItem.propTypes = {\n    todo: PropTypes.object.isRequired,\n    markComplete: PropTypes.func.isRequired,\n    delTodo: PropTypes.func.isRequired,\n}\n\n//can also use variable - only need one set of {}\n//const itemStyle = { backgroundColor: '#9999ff' }\n\nconst btnStyle = {\n    background: '#ff0000',\n    color: '#fff',\n    border: 'none',\n    padding: '5px 9px',\n    borderRadius: '50%',\n    cursor: 'pointer',\n    float: 'right',\n    class: 'responsive'\n}\n\n\nexport default TodoItem\n","//formatted like any other class based component\n\nimport React, { Component } from 'react';\nimport TodoItem from './TodoItem';\n//now prop-types are sort of a validation for properties that a component should have, and we can set the type we can also set them to be required or not, so our todo component has a prop of todos (App.js), so we import PropTypes\nimport PropTypes from 'prop-types';\n\nclass Todos extends Component {\n\n  //markComplete = () => {\n    //console.log(\"Hello\")\n  //}\n  // render method (JSX attribute) React.htmlATTRIBUTES<HTMLElement.className?:string\n\n  //then inside the class we have a render method, which is a lifecycle method and it's the only one that's actually required because it's needed to actually render the component in the browser and that's going to return what's called JSX. This looks like HTML but it's actually JSX. It's basically an easier way to write javascript for output in the browser. You could actually write in pure JavaScript but you would never want to, as it would be 20 times as hard, so that's why they use JSX. You can use javascript within JSX and put it between curley braces.\n  render() {\n\n    // next thing we want to do since we have this array of to do's we need to loop through them and then output something, so in react what we do is we use the map method, which is a high order array. and it's used it's used for a lot of different things but basically it can return an array from an array but we're,but we're just using it to loop through and then outputting JSX\n\n    // we get hello three times and the reason we're seeing hello three times is because they are coming from the state (App.js), passed in as props and we're mapping through those props and then we're outputting to-do item which only has < Hello /> inside of it (TodoItem), so obviously hello is not what we want to display here.\n\n    // remember this is a prop and todo is being passed into TodoItem as a prop\n    // in console you can see error saying each child in an array or iterator should have a unique key prop okay so that when we map through something it's actually creating what's called a list and lists need they should have keys you I mean it doesn't break the application but we'll just keep seeing this warning so we just simply want to add a key onto this which should be something unique now remember we have access to the todo and that to do has an ID which is unique so I'm going to say the key is going to be to do dot ID and we'll save and now that error goes away\n\n    return this.props.todos.map((todo) => (\n      //Creating prop of markComplete to this component\n      //< TodoItem key={todo.id} todo={todo} markComplete={this.markComplete}/>\n      //we have to go up one level, as state is in App.js, so we add props here, and then we attach markComplete to todos in App.js (and change the state)\n      //here we're creating props for delTodo (going up), same as markComplete\n      <TodoItem key={todo.id} todo={todo} markComplete={this.props.markComplete} delTodo={this.props.delTodo}/>\n      \n    ));\n\n    }\n  }\n  //PropTypes\n  //we want to define any prop-types for this class\n\n  // name of class (Todos) and then it's going to be an array of objects of Prop, and is required. This is good practice to do\n  // Todos.propTypes = { \n  //   todos: PropTypes.array.isRequired\n  //   }\n\n  Todos.propTypes = { \n    todos: PropTypes.array.isRequired,\n    //these are functions, not arrays\n    markComplete: PropTypes.func.isRequired,\n    delTodo: PropTypes.func.isRequired,\n    } \n\n  //adding PropTypes for these methods (todos, markComplete, delTodo)   \n\n  export default Todos;\n","import React from 'react'\n\nfunction About() {\n    \n    return (\n\n    // if you don't need a <div> in the dom, can use react fragment, which is like a ghost element in the dom, but we need it for JSX when returning something\n       <React.Fragment>\n          <h1>About</h1>\n           <p>This is the react-crash-todo App v0.1.0.  It is part of the React Crash Course.</p>\n            \n        </React.Fragment>\n    )\n}\n\nexport default About;\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\n//class based component\n\nexport class Addtodo extends Component {\n    //adding functionality. Here we have a an input field. Usually you're going to want to have your fields as a piece of State for that component, so we add a state value to our state object\n    state = {\n        title: ''\n    }\n\n    //since it's a submit, just like in vanilla javascript, it will just submit to the file, so we want to prevent that\n    \n    onSubmit = (e) => {\n        e.preventDefault();\n        //what we want to happen is that we need to pass this up, so we call a props method, just like makeComplete and delete. As a parameter we need to pass title up (whatever we're typing in, as we're adding a title)\n        this.props.addtodo(this.state.title);\n        //Here is we clearing field and setting our state object back to nothing after it's submitted. We have to again pass this up one level, to addTodo - so we go to App.js (as appTodo is embedded in App.js\n        this.setState({ title: ''});\n    }\n    //this is an example of component state and only exists within Addtodo component (and we don't need to go back up to App.js). The Todos however are at app level state because we're sharing that between components and that's what you would use redux for or context or even something like Apollo with graph QL (different ways to manage app level state, but this here is at component level state)\n\n    //this will give us the value of whatever we type in (so what we're doing is setting the title for whatever we type in.  We get the value using this event parameter). But what if we had other fields like name, email, password etc - we wouldn't want to do an onChange for each one, so this is what we do - so as long as name is equal to what's in the field (in this case title), that should be fine. We just have one field here but you can use as many fields as you want. \n    //onChange = (e) => {this.setState({ title: e.target.value })}\n    onChange = (e) => {this.setState({ [e.target.name]: e.target.value })}\n\n    render() {\n        return (\n            //here we're going to create a submit event\n            <form onSubmit = {this.onSubmit} style={{ display: 'flex' }}>\n                <input \n                 type=\"text\" \n                 name=\"title\"\n                 style = {{ flex: '10', padding: '5px' }} \n                 placeholder=\"Add todo ...\" \n                 value = {this.state.title}\n                 //doesn't matter what this is called, it is just the name of the method\n                 onChange = {this.onChange}\n\n                 />\n\n                <input \n                 type = \"submit\"\n                 value = \"Submit\" \n                 className = \"btn\"\n                 style = {{flex:'1', background:\"#555\", color:\"#fff\"}} \n                 class = \"responsive\"\n                 \n                 \n                 />\n            </form>\n        )\n    }\n}\n\nAddtodo.propTypes = {\n    //addtodo: PropTypes.object.isRequired,\n    //this is a function not an object\n    addtodo: PropTypes.func.isRequired\n}\n\nexport default Addtodo","//formatted like any other class based component\n\nimport React, { Component } from 'react';\nimport { BrowserRouter as Router, Route } from 'react-router-dom';\nimport Header from './components/layout/Header';\nimport Todos from './components/Todos';\nimport About from './components/pages/About';\nimport Addtodo from './components/Addtodo';\n//this will generate an id for each item added. Axios is a http library\nimport axios from 'axios';\n//import {v4 as uuid} from \"uuid\";\nimport './App.css';\n\n//const id = uuid()\n\nclass App extends Component {\n  //render method \n\n  //then inside the class we have a render method which is a lifecycle method and it's the only one that's actually required because it's needed to actually render the component in the browser and that's going to return what's called JSX. This looks like HTML but it's actually JSX. It's basically an easier way to write javascript for output in the browser. You could actually write in pure JavaScript but you would never want to, as it would be 20 times as hard, so that's why they use JSX. You can use javascript within JSX and put it between curley braces.\n\n  //creating javascript object and then array for todos\n    state = {\n      todos: []\n    }\n//using another lifecycle method 'componentDidMount' which runs after the component mounts\ncomponentDidMount () {\n  //this will give us a promise, then a response and it will have a data property attached. Adding a parameter limiting todos to 10\n  axios.get ('https://jsonplaceholder.typicode.com/todos?_limit=10')\n    //.then(res => console.log(res.data))\n    //we want to put the 10 todos in our state (in todos array)\n    .then(res => this.setState({todos:res.data}))\n  }\n// markComplete =() => {\n//   console.log(\"From App.js\")\n// }\n\n//Grabbing id, which has been passed through from TodoItem to Todos and now App.js\n// markComplete =(id ) => {\n//   console.log(id)\n// }\n\n// think of as the state like it's a cloud of data that hovers above all the components and then we're just sending something up to change it and then it rains back down. So it's it's a one-way data flow \n\n//now idea is to set state for each particular id. We're looking at state as a whole, which is an object, and we want to change something in 'todos', so we basically match the id that's passed in here and if it matches, we want to update the completed value when it's checked, so we will use map\nmarkComplete =(id ) => {\n  //here we use an arrow function and if statement to check that the current todo we're iterating through has an id that is equal to the id passed into the function\n  this.setState({todos: this.state.todos.map(todo => {\n    if(todo.id === id) {\n      //we're toggling here (toggle complete), so whatever the opposite is, we're setting it to. Toggline state at top and that state is being brought down through the props into components. State is like a cloud of data hovering above components and we're just sending something up to change it and then it reigns back down. It's a one-way data flow.\n\n      //now we want to delete items, doing same thing but calling a method on a prop and then it comes back up to App.js, and get rid of that todo\n      todo.completed = !todo.completed\n    }\n    return todo;\n  })});\n}\n//Delete Todo\n// delTodo = (id) => {\n//   console.log(id)\n// }\n\n//Manipulating our state by removing one of the deleted todos, and we use filter method (high order array method, which loops through and based on a condition it will return another array). We only want to return todos that don't match the id passed in, because we want to get rid of that one\n\n// delTodo = (id) => {\n// passing in our state object (we're dealing with the todos. We basically everything that's already there and use spread operator for that, which is 3 dots. So we want to filter out the id that is not the id here - in other words it's going to filter out the id that we're deleting). So when we click on item to delete, it will delete it but will come back when we reload, as we're not persisting to a database (even jason placeholder doesn't delete it from database, it doesn't have a backend, as react is a frontend UI framework/library, which takes care of the delete)\n\n//   this.setState ({ todos: [...this.state.todos.filter(todo => todo.id !== id)] });\n// }\n\n  // Delete Todo\n  // This will make the delete request and give us a promise back. This deletes it on the server and also updates the UI. So if this was our real backend (this placeholder) - if we were using node, express, PHP or Python, or some REST API, it would delete it from the database, and then would delete it all from the UI\n  delTodo = id => {\n    axios.delete(`https://jsonplaceholder.typicode.com/todos/${id}`).then(res =>\n      this.setState({\n        todos: [...this.state.todos.filter(todo => todo.id !== id)]\n      })\n    );\n  };\n\n  // Add Todo\n  //now we need to add Addtodo to our state, so we use setState and spread operator. We can't just change it, we basically have to make a copy of it and that's what the spread operator does. Creating object, title = title which is passed in and completed \n\n  //putting newTodo as a variable. So this should take the newTodo and add it to the state. When we add a new object it gets added but if we add another new object it has same id (4) as previous added object. When we get to json placeholder, an id is given when a new object is created\n\n  //when we're adding something we use a post request. \n\n  // now if we add a to do, we want to make a post request to the rest API right now and we're just adding it to the UI, which we still want to do but we also we want to make the request to json placeholder and then take the response and put that in here okay. We shouldn't have to use UUID anymore either so we can actually just comment it out. We want to do a post request, however it doesn't actually get placed on their server, so it mimicks a real life backend. The second parameter will be an object with the data that we want to send, so it's going to be the title, which is passed in here (since it's the same we don't even need to do that). \n\n  addtodo = title => {\n    axios\n      .post('https://jsonplaceholder.typicode.com/todos', {\n        title,\n        //completed with always be false\n        completed: false\n      })\n      //this then gives us a promise back and then will give us a response\n      .then(res => {\n        //res.data.id = uuid.v4();\n        //this will result in whatever it's going to give us back, which is the new todo (res.data). We can now test by adding a new todo, and it's added - what happened is that it went out and made the request to json placeholder and came back with information including id, and it got added to our UI, because if it didn't, this setState wouldn't have happened or if it hadn't gone through correctly. In fact, we could add a .catch error, but we're really running out of time. \n        this.setState({ todos: [...this.state.todos, res.data] });\n      });\n  };\n  \n  render() {\n    return (\n      <Router>\n        <div className=\"App\">\n          <div className=\"container\">\n            <Header />\n            <Route\n              exact\n              path=\"/\"\n              render={props => (\n                <React.Fragment>\n                  <Addtodo addtodo={this.addtodo} />\n                  <Todos\n                    todos={this.state.todos}\n                    markComplete={this.markComplete}\n                    delTodo={this.delTodo}\n                  />\n                </React.Fragment>\n              )}\n            />\n            <Route path=\"/about\" component={About} />\n          </div>\n        </div>\n      </Router>\n    );\n  }\n  }\n  \n  export default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nconst renderReactDom = () => {\n  ReactDOM.render(<App />, document.getElementById('root'));\n};\n\nif (window.cordova) {\n  document.addEventListener('deviceready', () => {\n    renderReactDom();\n  }, false);\n} else {\n  renderReactDom();\n}\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();"],"sourceRoot":""}